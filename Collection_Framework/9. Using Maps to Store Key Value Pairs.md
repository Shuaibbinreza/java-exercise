**Introduction to Map Hierarchy**

1. **Introduction to Map Hierarchy**
    - The Collections Framework provides an implementation of the hashmap structure, a fundamental data structure for storing key-value pairs.
2. **How Hashmaps Work**
    - Hashmaps store key-value pairs where:
        - The key represents a value uniquely.
        - The value can be any object, while the key is usually a simple object (string, number, etc.).
        - Keys allow retrieval of their corresponding values.
        - Keys are unique, but values don’t have to be.
        - A key-value pair forms an entry in the hashmap.
3. **Map Interface and Extensions**
    - The **Map interface** implements the key-value pair concept.
    - **SortedMap**: Maintains key-value pairs in sorted order.
    - **NavigableMap**: Extends SortedMap with additional navigation methods.
4. **Map Implementations in JDK**
    - **HashMap**: The most widely used implementation.
    - **LinkedHashMap**: Maintains insertion order of key-value pairs.
    - **IdentityHashMap**: Compares keys by reference (==) instead of equals() and hashCode().
5. **Multimaps**
    - A single key can be associated with multiple values (not directly supported in Java Collections).
    - This behavior can be achieved using maps with lists as values.

![image](https://github.com/user-attachments/assets/68261385-5318-4ce2-8eda-bc8ca1f49bae)


## **Using the Convenience Factory Methods for Collections to Create Maps**

1. **Java SE 9 Introduced Convenience Factory Methods for Maps**
    - Immutable maps can be created using Map.of() and Map.ofEntries().
2. **Creating Immutable Maps**
    - **For up to 10 key-value pairs** → Use Map.of():

Map&lt;Integer, String&gt; map = Map.of(1, "one", 2, "two", 3, "three");

- - **For more than 10 key-value pairs** → Use Map.ofEntries():
```
Map&lt;Integer, String&gt; map = Map.ofEntries(

  Map.entry(1, "one"),
  
  Map.entry(2, "two"),
  
  Map.entry(3, "three")

);
```

1. **Restrictions on These Factory Methods**
    - **Maps and entries are immutable** → No modifications allowed after creation.
    - **Null keys and values are not allowed** → Throws NullPointerException if attempted.
    - **Duplicate keys are not permitted** → Results in an IllegalArgumentException.
2. **Potential Interview Questions**
    - How do you create an immutable map in Java?
    - What are the differences between Map.of() and Map.ofEntries()?
    - Why are Map.of() and Map.ofEntries() considered more efficient than traditional HashMap initialization?
    - What happens if you try to insert null in Map.of()?

**Storing Key/Value Pairs in a Map**

### ****Key Points for Interview Preparation****

1. **Rules for Key-Value Relationships**
    - A **key** can be bound to only **one** value.
    - A **value** can be associated with **multiple keys**.
2. **Consequences for Map Structure**
    - **Keys are unique** → Forms a **Set** structure.
    - **Key-value pairs are unique** → Also follows a **Set** structure.
    - **Values can have duplicates** → Behaves like a **Collection**.
3. **Common Map Operations**
    - **Adding a key-value pair** (put(K, V)) → Fails if the key already exists.
    - **Retrieving a value** (get(K)) using its key.
    - **Removing a key-value pair** (remove(K)).
4. **Set-Like Operations on Maps**
    - **Check if empty** (isEmpty()).
    - **Get size** (size()).
    - **Merge another map** (putAll(Map&lt;K, V&gt;)).
    - **Clear all entries** (clear()).

### ****Potential Interview Questions****

- How does the uniqueness of keys affect map storage?
- What happens if you try to insert a duplicate key in a Map?
- How can you retrieve all unique keys and values from a Map?
- Explain the difference between containsKey(K) and containsValue(V).
- What is the difference between HashMap, LinkedHashMap, and TreeMap regarding ordering?

**Exploring the Map interface**

### ****Key Points for Interview Preparation****

1. **The Map Interface**
    - Base type that models key-value storage in Java.
    - Includes **Map.Entry&lt;K, V&gt;** to represent key-value pairs.
2. **Choosing Key Types Carefully**
    - **Using mutable keys is discouraged** → Mutating a key changes its hash code, making the entry **unrecoverable**.
    - Example of **a bad key choice**:

```
class MutableKey {

  int id;
  
  MutableKey(int id) { this.id = id; }
  
  public void setId(int newId) { this.id = newId; }
  
  @Override public int hashCode() { return id; }
  
  @Override public boolean equals(Object obj) { return (obj instanceof MutableKey) && this.id == ((MutableKey) obj).id; }
  
}

Map&lt;MutableKey, String&gt; map = new HashMap<>();

MutableKey key = new MutableKey(1);

map.put(key, "Value1");

key.setId(2); // Key mutated!

System.out.println(map.get(key)); // null! Entry is lost due to hash change.
```

1. **Map.Entry&lt;K, V&gt; Interface**
    - **Methods in Map.Entry**:
        - getKey() → Returns the key.
        - getValue() → Retrieves the value.
        - setValue(value) → Updates the value.
2. **Entries Are Views on the Map**
    - Modifying an entry’s value updates the original map.
    - **Keys cannot be changed** via Map.Entry to prevent corruption.
    - Example:

```
Map&lt;Integer, String&gt; map = new HashMap<>();

  map.put(1, "One");
  
  for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
  
  System.out.println(entry.getKey() + " -> " +entry.getValue());
  
  entry.setValue("Updated One"); // Changes reflect in the map

}

System.out.println(map.get(1)); // Output: "Updated One"
```
### ****Potential Interview Questions****

- Why should you avoid using mutable objects as map keys?
- How does modifying a Map.Entry affect the original map?
- Can you update a key inside Map.Entry? Why or why not?
- Explain the difference between HashMap, TreeMap, and LinkedHashMap in key ordering.
