# **Exploring the List Interface**

The [List](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/List.html) interface brings two new functionalities to plain collections.

- This order in which you iterate over the elements of a list is always the same, and it respects the order in which the elements have been added to this list.
- The elements of a list have an index.

### **Notes: Choosing Your Implementation of the List Interface**

#### **1\. List Interface Implementations**

- The **List** interface has two main implementations:
    1. **ArrayList** → Backed by an **internal array**.
    2. **LinkedList** → Implemented as a **doubly-linked list**.

#### **2\. Which One to Choose?**

- **Default Choice: ArrayList** (in most cases)
  - **Faster iteration** due to **better CPU cache usage**.
  - **Faster random access** using index-based lookup (O(1)).
  - **Better for most applications** unless frequent insertions/deletions are required.
- **When to Use LinkedList?**
  - **Fast insertions/removals** at the **beginning or end** (O(1)).
  - Best for **Last In, First Out (LIFO) stacks** and **First In, First Out (FIFO) queues**.
  - **Slower iteration** due to **pointer chasing** (extra memory overhead).

#### **3\. Performance Considerations**

| **Operation** | **ArrayList** | **LinkedList** |
| --- | --- | --- |
| **Random Access (get/set)** | **O(1)** (fast) | **O(n)** (slow) |
| **Insertion/Deletion at End** | **O(1)** (amortized) | **O(1)** |
| **Insertion/Deletion at Beginning** | **O(n)** | **O(1)** |
| **Insertion/Deletion in Middle** | **O(n)** | **O(n)** |
| **Iteration Speed** | **Fast** (cache-friendly) | **Slow** (pointer chasing) |

#### **4\. Key Takeaways**

- **Use ArrayList** if **frequent iteration** and **random access** are needed.
- **Use LinkedList** for **efficient insertions/removals** at the **beginning or end**.
- **Modern hardware favors ArrayList**, making it the **better default choice**.

### **Notes: Accessing the Elements Using an Index**

#### **1\. Methods for Accessing Elements by Index**

- **add(index, element)**:
  - Inserts the given element at the specified index.
  - Adjusts the indices of remaining elements.
- **get(index)**:
  - Retrieves the element at the specified index.
  - Throws **IndexOutOfBoundsException** if the index is invalid.
- **set(index, element)**:
  - Replaces the element at the given index with the new element.
- **remove(index)**:
  - Removes the element at the specified index and adjusts the indices of the remaining elements.
- **Exception Handling**:
  - Invalid index calls throw **IndexOutOfBoundsException**.

#### **2\. Finding the Index of an Object**

- **indexOf(element)**:
  - Returns the index of the first occurrence of the given element.
  - Returns **\-1** if the element is not found.
- **lastIndexOf(element)**:
  - Returns the index of the last occurrence of the given element.
  - Returns **\-1** if the element is not found.

#### **3\. Getting a SubList**

- **subList(start, end)**:
  - Returns a sublist from index **start** to **end - 1**.
  - Throws **IndexOutOfBoundsException** if the indexes are invalid.
  - The returned sublist is a **view** of the original list.
    - Any changes in the sublist reflect in the main list and vice-versa.
- **Example**:
```
List<String> strings = new ArrayList<>(List.of("0", "1", "2", "3", "4", "5"));
System.out.println(strings);
strings.subList(2, 5).clear();
System.out.println(strings);
```

**Output**:

\[0, 1, 2, 3, 4, 5\]

\[0, 1, 5\]

#### **4\. Inserting a Collection at an Index**

- **addAll(int index, Collection collection)**:
  - Inserts all elements from the given collection at the specified index in the list.

### **Notes: Sorting the Elements of a List**

#### **1\. Sorting in Java SE 7 and Earlier**

- Before Java SE 8, the **Collections.sort()** method was used to sort a List.
  - **Syntax**: Collections.sort(list)
  - You could pass a **Comparator** if custom sorting was needed.
  - **Example**:
  - Collections.sort(list, comparator);

#### **2\. Sorting in Java SE 8 and Later**

- **List.sort()** method introduced in Java SE 8.
  - Sorts the list in-place (modifies the original list).
  - **Syntax**:
  ```
   list.sort(comparator);
  ```
  - If no **Comparator** is passed, it will use the **natural ordering** of the elements (if they implement Comparable).
  - Passing a **null Comparator** will assume elements are **Comparable**, but will throw a **ClassCastException** if they are not.

#### **3\. Using** Comparator.naturalOrder()

- To avoid passing null, you can use **Comparator.naturalOrder()** for the natural ordering of the list's elements.
  - **Syntax**:
    ```
    list.sort(Comparator.naturalOrder());
    ```
#### **4\. Key Points to Remember**

- **Java SE 8** and later allows direct sorting using the sort() method.
- If elements of the List do **not implement Comparable**, you must provide a custom **Comparator**.
- **Comparator.naturalOrder()** can be used for natural sorting if elements are **Comparable**.

### **Notes: Iterating over the Elements of a List**

#### **1\. ListIterator Overview**

- The **ListIterator** interface extends the **Iterator** interface, providing additional methods for more advanced iteration over lists.
- You can obtain a **ListIterator** by calling **listIterator()** on a List.
  - **Syntax**:
  ```
  ListIterator<E> iterator = list.listIterator();
  ```
  - **Optional Index**: If an index is passed, iteration will start from that index.
  ```
  ListIterator<E> iterator = list.listIterator(index);
  ```

#### **2\. Key Methods of ListIterator**

- **hasPrevious()**:
  - Checks if there are more elements when iterating in the **reverse** direction.
- **previous()**:
  - Returns the previous element when iterating in the **reverse** direction.
- **nextIndex()**:
  - Returns the index of the element that will be returned by the next **next()** call.
- **previousIndex()**:
  - Returns the index of the element that will be returned by the next **previous()** call.
- **set(element)**:
  - Updates the last element returned by **next()** or **previous()**.
  - Throws **IllegalStateException** if neither **next()** nor **previous()** has been called.

#### **3\. Example: Using** set() **with ListIterator**

- This example demonstrates using **set()** to modify an element during iteration:
```
List<String> numbers = Arrays.asList("one", "two", "three");
for (ListIterator<String> iterator = numbers.listIterator(); iterator.hasNext();) {
    String nextElement = iterator.next();
    if (Objects.equals(nextElement, "two")) {
        iterator.set("2");
    }
}
System.out.println("numbers = " + numbers);
```

**Output**:

numbers = \[one, 2, three\]

#### **4\. Summary of ListIterator Advantages**

- **Bidirectional Iteration**: You can iterate both **forward** and **backward** through the list.
- **Element Update**: You can update elements during iteration with the **set()** method.
- **Index Tracking**: You can track the index of the current element using **nextIndex()** and **previousIndex()**.
